/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.mailodds.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.mailodds.models.AddPolicyRule201Response
import com.mailodds.models.CreatePolicyFromPresetRequest
import com.mailodds.models.CreatePolicyRequest
import com.mailodds.models.DeletePolicy200Response
import com.mailodds.models.DeletePolicyRule200Response
import com.mailodds.models.ErrorResponse
import com.mailodds.models.PolicyListResponse
import com.mailodds.models.PolicyPresetsResponse
import com.mailodds.models.PolicyResponse
import com.mailodds.models.PolicyRule
import com.mailodds.models.PolicyTestResponse
import com.mailodds.models.TestPolicyRequest
import com.mailodds.models.UpdatePolicyRequest

import com.squareup.moshi.Json

import com.mailodds.infrastructure.ApiClient
import com.mailodds.infrastructure.ApiResponse
import com.mailodds.infrastructure.ClientException
import com.mailodds.infrastructure.ClientError
import com.mailodds.infrastructure.ServerException
import com.mailodds.infrastructure.ServerError
import com.mailodds.infrastructure.MultiValueMap
import com.mailodds.infrastructure.PartConfig
import com.mailodds.infrastructure.RequestConfig
import com.mailodds.infrastructure.RequestMethod
import com.mailodds.infrastructure.ResponseType
import com.mailodds.infrastructure.Success
import com.mailodds.infrastructure.toMultiValue

open class ValidationPoliciesApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.mailodds.com/v1")
        }
    }

    /**
     * POST /v1/policies/{policy_id}/rules
     * Add rule to policy
     * Add a new rule to an existing policy.
     * @param policyId 
     * @param policyRule 
     * @return AddPolicyRule201Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addPolicyRule(policyId: kotlin.Int, policyRule: PolicyRule) : AddPolicyRule201Response {
        val localVarResponse = addPolicyRuleWithHttpInfo(policyId = policyId, policyRule = policyRule)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AddPolicyRule201Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v1/policies/{policy_id}/rules
     * Add rule to policy
     * Add a new rule to an existing policy.
     * @param policyId 
     * @param policyRule 
     * @return ApiResponse<AddPolicyRule201Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addPolicyRuleWithHttpInfo(policyId: kotlin.Int, policyRule: PolicyRule) : ApiResponse<AddPolicyRule201Response?> {
        val localVariableConfig = addPolicyRuleRequestConfig(policyId = policyId, policyRule = policyRule)

        return request<PolicyRule, AddPolicyRule201Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addPolicyRule
     *
     * @param policyId 
     * @param policyRule 
     * @return RequestConfig
     */
    fun addPolicyRuleRequestConfig(policyId: kotlin.Int, policyRule: PolicyRule) : RequestConfig<PolicyRule> {
        val localVariableBody = policyRule
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/policies/{policy_id}/rules".replace("{"+"policy_id"+"}", encodeURIComponent(policyId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v1/policies
     * Create policy
     * Create a new validation policy with rules.
     * @param createPolicyRequest 
     * @return PolicyResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createPolicy(createPolicyRequest: CreatePolicyRequest) : PolicyResponse {
        val localVarResponse = createPolicyWithHttpInfo(createPolicyRequest = createPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PolicyResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v1/policies
     * Create policy
     * Create a new validation policy with rules.
     * @param createPolicyRequest 
     * @return ApiResponse<PolicyResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createPolicyWithHttpInfo(createPolicyRequest: CreatePolicyRequest) : ApiResponse<PolicyResponse?> {
        val localVariableConfig = createPolicyRequestConfig(createPolicyRequest = createPolicyRequest)

        return request<CreatePolicyRequest, PolicyResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createPolicy
     *
     * @param createPolicyRequest 
     * @return RequestConfig
     */
    fun createPolicyRequestConfig(createPolicyRequest: CreatePolicyRequest) : RequestConfig<CreatePolicyRequest> {
        val localVariableBody = createPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/policies",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v1/policies/from-preset
     * Create policy from preset
     * Create a policy using a preset template.
     * @param createPolicyFromPresetRequest 
     * @return PolicyResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createPolicyFromPreset(createPolicyFromPresetRequest: CreatePolicyFromPresetRequest) : PolicyResponse {
        val localVarResponse = createPolicyFromPresetWithHttpInfo(createPolicyFromPresetRequest = createPolicyFromPresetRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PolicyResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v1/policies/from-preset
     * Create policy from preset
     * Create a policy using a preset template.
     * @param createPolicyFromPresetRequest 
     * @return ApiResponse<PolicyResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createPolicyFromPresetWithHttpInfo(createPolicyFromPresetRequest: CreatePolicyFromPresetRequest) : ApiResponse<PolicyResponse?> {
        val localVariableConfig = createPolicyFromPresetRequestConfig(createPolicyFromPresetRequest = createPolicyFromPresetRequest)

        return request<CreatePolicyFromPresetRequest, PolicyResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createPolicyFromPreset
     *
     * @param createPolicyFromPresetRequest 
     * @return RequestConfig
     */
    fun createPolicyFromPresetRequestConfig(createPolicyFromPresetRequest: CreatePolicyFromPresetRequest) : RequestConfig<CreatePolicyFromPresetRequest> {
        val localVariableBody = createPolicyFromPresetRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/policies/from-preset",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /v1/policies/{policy_id}
     * Delete policy
     * Delete a policy and all its rules.
     * @param policyId 
     * @return DeletePolicy200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deletePolicy(policyId: kotlin.Int) : DeletePolicy200Response {
        val localVarResponse = deletePolicyWithHttpInfo(policyId = policyId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeletePolicy200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /v1/policies/{policy_id}
     * Delete policy
     * Delete a policy and all its rules.
     * @param policyId 
     * @return ApiResponse<DeletePolicy200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deletePolicyWithHttpInfo(policyId: kotlin.Int) : ApiResponse<DeletePolicy200Response?> {
        val localVariableConfig = deletePolicyRequestConfig(policyId = policyId)

        return request<Unit, DeletePolicy200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deletePolicy
     *
     * @param policyId 
     * @return RequestConfig
     */
    fun deletePolicyRequestConfig(policyId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/v1/policies/{policy_id}".replace("{"+"policy_id"+"}", encodeURIComponent(policyId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /v1/policies/{policy_id}/rules/{rule_id}
     * Delete rule
     * Delete a rule from a policy.
     * @param policyId 
     * @param ruleId 
     * @return DeletePolicyRule200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deletePolicyRule(policyId: kotlin.Int, ruleId: kotlin.Int) : DeletePolicyRule200Response {
        val localVarResponse = deletePolicyRuleWithHttpInfo(policyId = policyId, ruleId = ruleId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeletePolicyRule200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /v1/policies/{policy_id}/rules/{rule_id}
     * Delete rule
     * Delete a rule from a policy.
     * @param policyId 
     * @param ruleId 
     * @return ApiResponse<DeletePolicyRule200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deletePolicyRuleWithHttpInfo(policyId: kotlin.Int, ruleId: kotlin.Int) : ApiResponse<DeletePolicyRule200Response?> {
        val localVariableConfig = deletePolicyRuleRequestConfig(policyId = policyId, ruleId = ruleId)

        return request<Unit, DeletePolicyRule200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deletePolicyRule
     *
     * @param policyId 
     * @param ruleId 
     * @return RequestConfig
     */
    fun deletePolicyRuleRequestConfig(policyId: kotlin.Int, ruleId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/v1/policies/{policy_id}/rules/{rule_id}".replace("{"+"policy_id"+"}", encodeURIComponent(policyId.toString())).replace("{"+"rule_id"+"}", encodeURIComponent(ruleId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/policies/{policy_id}
     * Get policy
     * Get a single policy with its rules.
     * @param policyId 
     * @return PolicyResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPolicy(policyId: kotlin.Int) : PolicyResponse {
        val localVarResponse = getPolicyWithHttpInfo(policyId = policyId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PolicyResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/policies/{policy_id}
     * Get policy
     * Get a single policy with its rules.
     * @param policyId 
     * @return ApiResponse<PolicyResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPolicyWithHttpInfo(policyId: kotlin.Int) : ApiResponse<PolicyResponse?> {
        val localVariableConfig = getPolicyRequestConfig(policyId = policyId)

        return request<Unit, PolicyResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPolicy
     *
     * @param policyId 
     * @return RequestConfig
     */
    fun getPolicyRequestConfig(policyId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/policies/{policy_id}".replace("{"+"policy_id"+"}", encodeURIComponent(policyId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/policies/presets
     * Get policy presets
     * Get available preset templates for quick policy creation.
     * @return PolicyPresetsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPolicyPresets() : PolicyPresetsResponse {
        val localVarResponse = getPolicyPresetsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PolicyPresetsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/policies/presets
     * Get policy presets
     * Get available preset templates for quick policy creation.
     * @return ApiResponse<PolicyPresetsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPolicyPresetsWithHttpInfo() : ApiResponse<PolicyPresetsResponse?> {
        val localVariableConfig = getPolicyPresetsRequestConfig()

        return request<Unit, PolicyPresetsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPolicyPresets
     *
     * @return RequestConfig
     */
    fun getPolicyPresetsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/policies/presets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/policies
     * List policies
     * List all validation policies for your account. Includes plan limits.
     * @param includeRules Include full rules in response (optional, default to false)
     * @return PolicyListResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listPolicies(includeRules: kotlin.Boolean? = false) : PolicyListResponse {
        val localVarResponse = listPoliciesWithHttpInfo(includeRules = includeRules)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PolicyListResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/policies
     * List policies
     * List all validation policies for your account. Includes plan limits.
     * @param includeRules Include full rules in response (optional, default to false)
     * @return ApiResponse<PolicyListResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listPoliciesWithHttpInfo(includeRules: kotlin.Boolean?) : ApiResponse<PolicyListResponse?> {
        val localVariableConfig = listPoliciesRequestConfig(includeRules = includeRules)

        return request<Unit, PolicyListResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listPolicies
     *
     * @param includeRules Include full rules in response (optional, default to false)
     * @return RequestConfig
     */
    fun listPoliciesRequestConfig(includeRules: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (includeRules != null) {
                    put("include_rules", listOf(includeRules.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/policies",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /v1/policies/test
     * Test policy evaluation
     * Test how a policy would evaluate a validation result without affecting production.
     * @param testPolicyRequest 
     * @return PolicyTestResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun testPolicy(testPolicyRequest: TestPolicyRequest) : PolicyTestResponse {
        val localVarResponse = testPolicyWithHttpInfo(testPolicyRequest = testPolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PolicyTestResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /v1/policies/test
     * Test policy evaluation
     * Test how a policy would evaluate a validation result without affecting production.
     * @param testPolicyRequest 
     * @return ApiResponse<PolicyTestResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun testPolicyWithHttpInfo(testPolicyRequest: TestPolicyRequest) : ApiResponse<PolicyTestResponse?> {
        val localVariableConfig = testPolicyRequestConfig(testPolicyRequest = testPolicyRequest)

        return request<TestPolicyRequest, PolicyTestResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation testPolicy
     *
     * @param testPolicyRequest 
     * @return RequestConfig
     */
    fun testPolicyRequestConfig(testPolicyRequest: TestPolicyRequest) : RequestConfig<TestPolicyRequest> {
        val localVariableBody = testPolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v1/policies/test",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * PUT /v1/policies/{policy_id}
     * Update policy
     * Update a policy&#39;s settings (name, enabled, default).
     * @param policyId 
     * @param updatePolicyRequest 
     * @return PolicyResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updatePolicy(policyId: kotlin.Int, updatePolicyRequest: UpdatePolicyRequest) : PolicyResponse {
        val localVarResponse = updatePolicyWithHttpInfo(policyId = policyId, updatePolicyRequest = updatePolicyRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PolicyResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PUT /v1/policies/{policy_id}
     * Update policy
     * Update a policy&#39;s settings (name, enabled, default).
     * @param policyId 
     * @param updatePolicyRequest 
     * @return ApiResponse<PolicyResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updatePolicyWithHttpInfo(policyId: kotlin.Int, updatePolicyRequest: UpdatePolicyRequest) : ApiResponse<PolicyResponse?> {
        val localVariableConfig = updatePolicyRequestConfig(policyId = policyId, updatePolicyRequest = updatePolicyRequest)

        return request<UpdatePolicyRequest, PolicyResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updatePolicy
     *
     * @param policyId 
     * @param updatePolicyRequest 
     * @return RequestConfig
     */
    fun updatePolicyRequestConfig(policyId: kotlin.Int, updatePolicyRequest: UpdatePolicyRequest) : RequestConfig<UpdatePolicyRequest> {
        val localVariableBody = updatePolicyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/v1/policies/{policy_id}".replace("{"+"policy_id"+"}", encodeURIComponent(policyId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
